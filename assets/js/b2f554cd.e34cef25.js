"use strict";(self.webpackChunkhatrickek_site=self.webpackChunkhatrickek_site||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"oxylus-first-game","metadata":{"permalink":"/blog/oxylus-first-game","source":"@site/blog/oxylus-first-game/2023-03-19-oxylus-first-game.md","title":"Creating A Game With Oxylus","description":"This blog is pretty outdated. While ECS System\'s still applies the API have evolved quite a lot and there is now Lua scripting as well. I\'ll just keep this blog as a relic :)","date":"2023-03-19T00:00:00.000Z","formattedDate":"March 19, 2023","tags":[{"label":"blog","permalink":"/blog/tags/blog"}],"readingTime":5.685,"hasTruncateMarker":false,"authors":[{"name":"Hatrickek","url":"https://github.com/Hatrickek","imageURL":"https://avatars.githubusercontent.com/u/89982837?v=4","key":"Hatrickek"}],"frontMatter":{"slug":"oxylus-first-game","title":"Creating A Game With Oxylus","authors":["Hatrickek"],"tags":["blog"]}},"content":"### This blog is pretty outdated. While ECS System\'s still applies the API have evolved quite a lot and there is now Lua scripting as well. I\'ll just keep this blog as a relic :)\\r\\n\\r\\nFor the purpose of testing Oxylus\' capabilities and identifying any missing features, I have decided to make a game using the engine. This project will serve as a stress test to see how well the engine can handle complex gameplay scenarios, while also providing an opportunity to showcase its current features. Furthermore, while working on the game, I\'ll be able to spot any features that are missing or need improvement. This way, I can add them to the engine and make it even better!\\r\\n\\r\\nThe game I chose to remake in 3D is [1985 Cyclone](<https://en.wikipedia.org/wiki/Cyclone_(video_game)>). It looked simple and is enough to showcase almost all features of the engine.\\r\\n\\r\\nIn this blog post I will show the steps I took to create the game, similar to a tutorial you might find for popular engines like Unity, Unreal or etc.\\r\\n\\r\\nSo let us begin...\\r\\n\\r\\n## Project\\r\\n\\r\\nThe project selection panel is the first thing you will see when launching the engine. The top rows displays recent projects that have been opened, and below that are buttons to load or create projects with a file dialog.\\r\\n![Project Selector](projects.png)\\r\\n\\r\\nIn Oxylus, a project is simply a YAML file that specifies the project name, starting scene path, and asset directory:\\r\\n\\r\\n```yml\\r\\nProject:\\r\\n  Name: ProjectCyclone\\r\\n  StartScene: \\"Scenes/Main.oxscene\\"\\r\\n  AssetDirectory: \\"Assets\\"\\r\\n```\\r\\n\\r\\n## Scene\\r\\n\\r\\nFirst of all, we need assets to load for our scene. I found a nice [helicopter model](https://sketchfab.com/3d-models/low-poly-helicopter-5bbed2de9baa4a13a7faa72653b78b64)\\r\\nfrom Sketchfab. To import assets into Oxylus, simply download the asset and drag and drop it into the editor. Oxylus will automatically load all meshes and materials and create parented entities based on the glTF node hierarchy.\\r\\n![Scene](scene.png)\\r\\n\\r\\nTo create ground in the game, I used a plane and applied a green material to it. I created the material first, then simply draged and dropped it onto the plane in the editor.\\r\\n![Material](Material.gif)\\r\\n\\r\\n## Systems\\r\\n\\r\\nOne of the most useful features of editing scenes in Oxylus is the ability to see the results immediately during runtime. To achieve this, I implemented the `HotReloadableScene` system using the Oxylus Systems and Event System. With `HotReloadableScene`, you can make changes to a scene and see the changes take effect in real-time, making the editing process much faster and more efficient.\\r\\n\\r\\nSystems in Oxylus are inherited from the `System` interface.\\r\\n\\r\\n```cpp\\r\\nclass System {\\r\\npublic:\\r\\n  std::string Name;\\r\\n  System() = default;\\r\\n  System(std::string name) : Name(std::move(name)) {}\\r\\n  virtual ~System() = default;\\r\\n  virtual void OnInit() {};\\r\\n  virtual void OnUpdate() {}\\r\\n  virtual void OnUpdate(Scene* scene) {}\\r\\n  virtual void OnShutdown() {};\\r\\n  void SetDispatcher(EventDispatcher* dispatcher) { m_Dispatcher = dispatcher; }\\r\\nprotected:\\r\\n  EventDispatcher* m_Dispatcher = nullptr;\\r\\n};\\r\\n```\\r\\n\\r\\nDefining the `HotReloadableScene` system:\\r\\n\\r\\n```cpp\\r\\nvoid HotReloadableScenes::OnUpdate() {\\r\\n  using namespace std::filesystem;\\r\\n  if (last_write_time(m_ScenePath).time_since_epoch().count()\\r\\n      != m_LastWriteTime.time_since_epoch().count()) {\\r\\n    //File changed event\\r\\n    m_Dispatcher->trigger<ReloadSceneEvent>();\\r\\n    m_LastWriteTime = last_write_time(m_ScenePath);\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n`m_Dispatcher->trigger<ReloadSceneEvent>();` is the way to simply trigger the `ReloadSceneEvent`.\\r\\n\\r\\nThe `OnAttach` callback on the `GameLayer` listens for the system event:\\r\\n\\r\\n```cpp\\r\\nvoid GameLayer::OnAttach(EventDispatcher& dispatcher) {\\r\\n  dispatcher.sink<ReloadSceneEvent>().connect<&GameLayer::OnSceneReload>(*this);\\r\\n}\\r\\n\\r\\nbool GameLayer::OnSceneReload(ReloadSceneEvent&) {\\r\\n  LoadScene();\\r\\n  OX_CORE_INFO(\\"Scene reloaded.\\");\\r\\n  return true;\\r\\n}\\r\\n```\\r\\n\\r\\nNext, we add the system to the engine during the application creation process:\\r\\n\\r\\n```cpp\\r\\nconst auto app = new ProjectCyclone(spec);\\r\\napp->PushLayer(new ::ProjectCyclone::GameLayer())\\r\\n    .AddSystem<HotReloadableScenes>(\\"Assets/Scenes/Main.oxscene\\");\\r\\n```\\r\\n\\r\\n![HotReloadableScenes](HotReloadableScene.gif)\\r\\n\\r\\n## Gameplay\\r\\n\\r\\nNow we can move onto the fun part of game development and prove wrong the infamous phrase about engine developers \ud83d\ude1b:\\r\\n\\r\\n> Give someone an engine and they\'ll make a game. Teach someone to make an engine and they\'ll never make anything.\\r\\n\\r\\nI started by creating a simple helicopter system to move the helicopter and make the propellers turn around itself.\\r\\n\\r\\nWe could have used the `ScriptableEntity` approach, but instead, I opted for the \\"raw\\" ECS method as I did not require any callbacks from the `ScriptableEntity` API.\\r\\n\\r\\nThe component that will be added on helicopter entity:\\r\\n\\r\\n```cpp\\r\\nstruct HeliComponent {\\r\\n  float Speed = 5.0f;\\r\\n  float Fuel = 1.0f;  //1.0f = Full, 0.0f = Empty\\r\\n  float Altitude = 0.0f;\\r\\n};\\r\\n```\\r\\n\\r\\nUsing the same method as we used to declare the engine system in the previous section, we can now declare a system for the Helicopter entities.\\r\\n\\r\\n```cpp\\r\\nvoid HeliSystem::OnUpdate(Scene* scene) {\\r\\n  auto& registery = scene->m_Registry;\\r\\n    const auto view = registery.view<TransformComponent, HeliComponent>();\\r\\n    for (const auto entity : view) {\\r\\n      auto&& [transform, heli] = view.get<TransformComponent, HeliComponent>(entity);\\r\\n\\r\\n      //Move horizontal\\r\\n      if (Input::GetKeyDown(Key::W)) {\\r\\n        transform.Translation.z += heli.Speed * Timestep::GetDeltaTime();\\r\\n      }\\r\\n      //...\\r\\n      //Other keys\\r\\n      //...\\r\\n\\r\\n      //Move vertical\\r\\n      if (Input::GetKeyDown(Key::Q) && heli.Altitude >= 0.2f) {\\r\\n        transform.Translation.y -= heli.Speed * Timestep::GetDeltaTime();\\r\\n      }\\r\\n      else if (Input::GetKeyDown(Key::E) && heli.Altitude < 8.0f) {\\r\\n        transform.Translation.y += heli.Speed * Timestep::GetDeltaTime();\\r\\n      }\\r\\n\\r\\n      heli.Fuel -= 0.1f * ImGui::GetIO().DeltaTime;\\r\\n      heli.Altitude = transform.Translation.y;\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\nFor rotating the propeller just getting the transform component and adding a constant value to `y` rotation should work for now.\\r\\n\\r\\n```cpp\\r\\nauto ent = Oxylus::Entity { entity, m_Scene.get() };\\r\\nent.GetChild(1).GetComponent<Oxylus::TransformComponent>().Rotation.y += 5.0f;\\r\\n```\\r\\n\\r\\nOther gameplay elements that could be added include picking up crates from the ground. Similar to how we created the helicopter system, we can now create a system for the crates.\\r\\n\\r\\n```cpp\\r\\nconst auto heliView = scene->m_Registry.view<TransformComponent, HeliComponent>();\\r\\nconst auto crateView = scene->m_Registry.view<TransformComponent, CrateComponent>();\\r\\nfor (const auto entity : crateView) {\\r\\n  auto&& [transform, crate] = crateView.get<TransformComponent, CrateComponent>(entity);\\r\\n  const auto ent = Entity{entity, scene};\\r\\n  constexpr float axisThreshold = 0.5f;\\r\\n  //a simple intersection check\\r\\n  for (const auto heliEntity : heliView) {\\r\\n    auto&& [heliTransform, heli] = heliView.get<TransformComponent, HeliComponent>(heliEntity);\\r\\n    if (std::abs(transform.Translation.x - heliTransform.Translation.x) < axisThreshold\\r\\n        && std::abs(transform.Translation.y + 0.2f - heliTransform.Translation.y) < axisThreshold\\r\\n        && std::abs(transform.Translation.z - heliTransform.Translation.z) < axisThreshold) {\\r\\n      heli.CratesTaken += 1;\\r\\n      scene->DestroyEntity(ent);\\r\\n      break;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n![Crates](https://cdn.discordapp.com/attachments/1022588581237248060/1088469165813268510/crates.gif)\\r\\n\\r\\nAs you may have noticed, the camera is currently static. Since the player will be moving around frequently, we want to ensure that the helicopter remains in focus. Simply snapping the camera to a predefined position whenever the player moves would not look good. Therefore, we can utilize the `OxMath` API to create a camera system with smooth damping that produces more visually pleasing result.\\r\\n\\r\\n```cpp\\r\\nm_LastCameraPosition = Math::SmoothDamp(m_LastCameraPosition,\\r\\n                                        heliTransform.Translation,\\r\\n                                        m_TranslationVelocity,\\r\\n                                        TranslationDampening,\\r\\n                                        10000.0f,\\r\\n                                        Timestep::GetDeltaTime());\\r\\ncameraTransform.Translation.x = m_LastCameraPosition.x;\\r\\ncameraTransform.Translation.z = m_LastCameraPosition.z + 12.0f;\\r\\n```\\r\\n\\r\\n![SmootCam](https://cdn.discordapp.com/attachments/1022588581237248060/1090994911869943898/smoothcam.gif)\\r\\n\\r\\n## UI\\r\\n\\r\\nTo create the game UI, we can use the `OxUI` API which is built on top of `Dear ImGui` for drawing and layouts. In Cyclone, we need a HUD that displays instrumentation such as speed, altitude, fuel remaining and time remaining. We\'ll also show the number of supply crates, the player\'s current view direction, wind force, and a warning about the cyclone\'s proximity and any approaching planes. For simplicity, we\'ll start with showing altitude, remaining fuel, and time.\\r\\n\\r\\n```cpp\\r\\nOxUI::BeginUI();\\r\\nOxUI::ProgressBar(\\"Time\\", Time);\\r\\nOxUI::ProgressBar(\\"Fuel\\", Heli.Fuel);\\r\\nOxUI::Property(\\"Altitude\\", \\"%.1f\\", Heli.Altitude);\\r\\nOxUI::EndUI();\\r\\n```\\r\\n\\r\\n![UI](https://cdn.discordapp.com/attachments/1022588581237248060/1087718914886221904/image.png)\\r\\n\\r\\nTo keep track of the collected crates, we can simply use glyphs as icons in a row:\\r\\n\\r\\n```cpp\\r\\nImGui::Text(StringUtils::FromChar8T(ICON_MDI_CUBE));\\r\\n```\\r\\n\\r\\n![CratesUI](https://cdn.discordapp.com/attachments/1022588581237248060/1090992608567894056/Annotation_2023-03-30_163445.png)\\r\\n\\r\\n# TO BE CONTINUED..."}]}')}}]);